\documentclass{beamer}
\usetheme{Copenhagen}
\usepackage{minted}
%\usecolortheme{beetle}
%\usecolortheme{seahorse}
%\usecolortheme{rose}
\usecolortheme[snowy]{owl}
\usetheme{default}

% Title page details
\title{muse: Memory management of persistent memory in userspace}
\subtitle{Giving userspace control over dynamic virtual machine guest memory to survive kexec}
\author[James Gowans \& David Woodhouse (EC2) ]{James Gowans (\texttt{jgowans@amazon.com}) \\ \and David Woodhouse (\texttt{dwmw2@infradead.org})}
\institute{Amazon / AWS / EC2}
\date{LPC, MM MC, September 2022}

\begin{document}

\begin{frame}
% Print the title page as the first slide
\titlepage
\end{frame}


\begin{frame}{Agenda}
  \tableofcontents[hideallsubsections]
\end{frame}

% Current section
%\AtBeginSection[ ]
%{
%\begin{frame}{Outline}
%    \tableofcontents[currentsection]
%\end{frame}
%}

\section{Background, Problem and Requirements}

\begin{frame}{Live update memory management}
    Live update of hypervisor via kexec:

    serialise \texttt{->} kexec \texttt{->} deserialise \texttt{->} run
    
    Persist guest memory and state across live update (kexec). Can't be ``normal'' kernel allocations.
  \begin{itemize}
    \item Basic case: fixed allocation at launch.
    \item Side-car VM: carve out portion of memory to read-only
    \item Memory overcommit: dynamic allocation/reclaim incl swap
    \item Deliver faults to userspace for post-copy LM.
    \item Pass through slice of PCI BAR
    \item Keep DMA running during kexec: IOMMU persistent pgtables
  \end{itemize}
  Idea floated at LSF/MM earlier this year: https://lwn.net/Articles/895453/

  Make live update properly supported!
\end{frame}

\begin{frame}{Proposal: Memory management in userspace}
  Guest memory and state should not touched by new kernel on kexec: \texttt{mem=}
  
  \includegraphics[width=0.5\textwidth]{memmac-memory}

  Control process: own persistent memory, program allocations into kernel.

  Client process (VMM): use those allocation in non-privileged way.
  \newline
  Play nicely with something like userfaultfd; only anonymous mem currently.
\end{frame}


\section{Implementation Options}

\subsection{Options considered: userspace vs kernel}
\begin{frame}{Options considered}
  \textbf{Filesystem with userspace control:} Filesystem backed by non-kernel managed memory.
  Provide privileged userspace process the ability to control memory mappings (\texttt{pg\_offset} to \texttt{PFN}) of files.
  Userspace takes and resolves faults. Updates mappings dynamically.\\
  
  \textbf{Fully kernel management persistence:} No control process: kernel allocator handles all faults.
  Like pkram[1] RFC. How to expose 

  [1] https://lwn.net/Articles/851192/
  Think \texttt{tempfs} with persistence.
\end{frame}

\begin{frame}{Suggestion: filesystem with userspace control}
  Justification:
  \begin{itemize}
    \item Avoids attempting to expose allocation policies and things like swap to persistent memory.
    \item Foo.
  \end{itemize}
\end{frame}

\section{Proposal: ``mmuse'' fs (mem mgmt in userspace)}
\begin{frame}{Proposal: ``mmuse'' fs (mem mgmt in userspace)}
  In-memory filesystem. Mappings controlled by userspace. Backed by non-kernel managed memory.\\

  Similar to fuse (userspace control) but mappings not block data.

  Control process usage:
  \begin{itemize}
    \item Carve out large chunk of host memory via \texttt{mem=} param.
    \item Mount mmuse, setting backing file something with the carved out memory: \texttt{/dev/mem}, \texttt{DAX} device, etc.
    \item Create files, initially empty containers
    \item Assign/re-assign mappings via \texttt{ioctl}s.
  \end{itemize}
\end{frame}
\section{Discussion and Questions}

\begin{frame}[fragile]
  Example: Set up filesystem and backing memory. Mount:

  \begin{minted}{c}
    mount -t mmuse guest-memory /mnt/guest-memory
  \end{minted}
  \vspace{1cm}
  Initially admin file for control process:
  \begin{minted}{c}
    ls -l /mnt/guest-memory/
    -rw-rw---- 1 root root   0 Aug  4 00:00  admin
  \end{minted}
  \vspace{0.8cm}
  Set backing to \texttt{/dev/mem}:
  \begin{minted}{c}
    int admin_fd = open("/mnt/guest-memory/admin")
    int devmem_fd = open("/dev/mem")
    ioctl(admin_fd, SET_BACKING_FD, devmem_fd)
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Example: Programming a mapping from backing memory to a file:
  \begin{minted}{c}
  dst_fd = open("/mnt/guest-memory/dom123_0_3GiB");
  struct mmuse_mapping mapping = {
    .dst = dst_fd,
    .src_start = 100 * GiB,
    .dst_start = 0,
    .size = 3 * GiB,
    .granulaity = GIGANTIC_PAGE // lvl 3 -> 1 GiB
  };
  ioctl(admin_fd, MAP_MEMORY_RANGE, &dst_fd);
  \end{minted}

  When client processes mmaps that file it would get backing memory, faulting in 1 GiB PTEs.

  Control process would replay after live update.
\end{frame}

\begin{frame}[fragile]
  Example: heirarchy using one mmuse file as backing memory for another:\\

  \begin{minted}{c}
  int source_fd = open("/mnt/guest_memory/dom:123_memory")

  mount -t mmuse dom:123_memory /mnt/dom:123_memory
  int admin_fd = open("/mnt/dom:123_memory/admin")

  ioctl(admin_fd, SET_BACKING_FD, source_fd)
  \end{minted}
  \vspace{0.7cm}
  Use case: hand over large chunk of memory to guest VMM. That VMM can carve it up for sidecar VMs.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: memory overcommit}
  Memory overcommit: reclaim a chunk of memory currently assigned to a file:

  \begin{minted}{c}
  struct mappings = {
    .dst = dst_fd,
    .src_start = (100 << 30),
    .dst_start = 0,
    .size = (16 << 20)
  }
  ioctl(admin_fd, UNMAP_MEMORY_RANGE, &dst_fd);}
  \end{minted}
  \vspace{0.7cm}
  Use case: hand over large chunk of memory to guest VMM. That VMM can carve it up for sidecar VMs.
\end{frame}

\begin{frame}{Discussion and Questions}
  \begin{itemize}
    \item Open floor for questions/comments.
    \item Some ideas for feedback:
      \begin{enumerate}
        \item Are we re-inventing or overcomplicating this?
        \item Other use-cases than live-update?
        \item Other ideas to solve this which we should look at?
        \item Which approach to go for?
      \end{enumerate}
  \end{itemize}
\end{frame}

\end{document}
